import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from utils.GetClassicOrbitalElements import *
from utils.visualization import plot_classic_orbital_elements


r = np.array([10016.34, -17012.52, 7899.28])
v = np.array([2.5, -1.05, 3.88])
t = np.linspace(0, 200000, 1000000)
earth_radius = 6378.0  # in km
mu = 3.986e5
thrust = 1.1e-3

# ===================== ADIÇÕES (H e janelas em anomalia verdadeira) =====================
# Acelerações efetivas (defina direto em km/s^2 se quiser "massa desprezível")
m_sat = 12.0
aV = (thrust/m_sat)/1000.0   # km/s^2, empuxo tangencial V (deixe ligado p/ espiral)  ← pode comentar se quiser V=off
aH = (thrust/m_sat/1000.0)                  # km/s^2, empuxo em H (normal ao plano) durante a janela

# Parâmetros das janelas de anomalia verdadeira (em graus):
THRUST_INTERVAL_DEG = 10.0                       # largura total (ex.: 10°)
MEAN_THETA_LIST_DEG = [180.0]                    # centros das janelas (ex.: 180° = apogeu)
# Ex.: várias janelas:
# MEAN_THETA_LIST_DEG = [180.0, 90.0, 270.0]

def wrap_deg(a):
    """Normaliza ângulo para [0, 360)."""
    return (a % 360.0 + 360.0) % 360.0

def angle_in_window_deg(theta_deg, center_deg, width_deg):
    """Retorna True se theta estiver dentro da janela centrada em center_deg com largura width_deg."""
    half = 0.5*width_deg
    lo = wrap_deg(center_deg - half)
    hi = wrap_deg(center_deg + half)
    th = wrap_deg(theta_deg)
    if lo <= hi:
        return (th >= lo) and (th <= hi)
    else:
        # janela cruza 0/360
        return (th >= lo) or (th <= hi)

def true_anomaly_deg(r_vec, v_vec, mu):
    """
    Computa anomalia verdadeira θ em graus a partir de (r,v).
    Usa atan2 robusto:
      cosθ = (e·r)/(e r),  sinθ = (h·(r×e))/(h e r)
    """
    rnorm = np.linalg.norm(r_vec)
    v2 = np.dot(v_vec, v_vec)
    h_vec = np.cross(r_vec, v_vec);  h = np.linalg.norm(h_vec)
    e_vec = (np.cross(v_vec, h_vec)/mu) - (r_vec/max(rnorm,1e-12))
    e = np.linalg.norm(e_vec)
    if e < 1e-12:
        # órbita ~circular: defina θ pela anomalia argumentada do vetor posição contra direção transversal
        r_hat = r_vec/max(rnorm,1e-12)
        t_hat = np.cross(h_vec/max(h,1e-12), r_hat)
        cos_th = np.dot(r_hat, r_vec)/max(rnorm,1e-12)   # = 1
        sin_th = np.dot(t_hat, r_vec)/max(rnorm,1e-12)   # ~0
        th = np.degrees(np.arctan2(sin_th, cos_th))
        return wrap_deg(th)
    # geral (elíptica)
    cos_th = np.dot(e_vec, r_vec)/(max(e,1e-12)*max(rnorm,1e-12))
    cos_th = np.clip(cos_th, -1.0, 1.0)
    sin_th = np.dot(h_vec, np.cross(r_vec, e_vec)) / (max(h,1e-12)*max(e,1e-12)*max(rnorm,1e-12))
    th = np.degrees(np.arctan2(sin_th, cos_th))
    return wrap_deg(th)
# ========================================================================================

def x_dot(t, x):
    xdot = np.zeros_like(x)
    xdot[0] = x[3]
    xdot[1] = x[4]
    xdot[2] = x[5]

    # Gravidade
    r_vec = x[0:3]
    v_vec = x[3:6]
    rnorm = np.linalg.norm(r_vec)
    xdot[3:6] = -(mu/(rnorm**3))*r_vec

    # (opcional) Empuxo tangencial V para espiral (pode comentar estas 3 linhas se quiser V=off)
    vnorm = np.linalg.norm(v_vec)
    if vnorm > 0:
        v_hat = v_vec / vnorm
        xdot[3:6] += aV * v_hat

    # Empuxo H: liga se θ estiver em qualquer janela configurada
    h_vec = np.cross(r_vec, v_vec)
    h_norm = np.linalg.norm(h_vec)
    if h_norm > 0.0:
        theta_deg = true_anomaly_deg(r_vec, v_vec, mu)
        fire_H = any(angle_in_window_deg(theta_deg, cdeg, THRUST_INTERVAL_DEG) for cdeg in MEAN_THETA_LIST_DEG)
        if fire_H:
            h_dir = h_vec / h_norm
            xdot[3:6] += aH * h_dir

    return xdot

x0 = np.concatenate((r, v)) 
sol = solve_ivp(x_dot, (t[0], t[-1]), x0, t_eval=t, method='RK45')

X = sol.y

orbital_elementss = []
for i in range(X.shape[1]):
    x = X[:, i]
    orbital_elementss.append(get_orbital_elements(x[0:3], x[3:6], mu))

plt.figure()
ax = plt.axes(projection='3d')
u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
x = earth_radius * np.cos(u)*np.sin(v)
y = earth_radius * np.sin(u)*np.sin(v)
z = earth_radius * np.cos(v)
ax.plot_wireframe(x, y, z, color="r")
ax.plot3D(X[0, :], X[1, :], X[2, :], 'b-')
ax.set_title('Orbit Propagation')
ax.axis('equal')
plt.show()

nus_deg = []
incs_deg = []
for k in range(X.shape[1]):
    r_vec = X[0:3, k]
    v_vec = X[3:6, k]

    # anomalia verdadeira (graus) usando a função que você já tem
    nu_k = true_anomaly_deg(r_vec, v_vec, mu)
    nus_deg.append(nu_k)

    # inclinação a partir do momento angular h = r x v
    h_vec = np.cross(r_vec, v_vec)
    h_norm = np.linalg.norm(h_vec) + 1e-12
    cos_i = np.clip(h_vec[2] / h_norm, -1.0, 1.0)
    i_k = np.degrees(np.arccos(cos_i))
    incs_deg.append(i_k)

plt.figure()
plt.plot(nus_deg, incs_deg, '.', ms=1.0)
plt.xlim(0, 360)
plt.xlabel('Anomalia Verdadeira, ν (graus)')
plt.ylabel('Inclinação, i (graus)')
plt.title('Inclinação vs Anomalia Verdadeira')
plt.grid(True, alpha=0.3)
plt.show()


plot_classic_orbital_elements(t, orbital_elementss)
